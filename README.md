# DeSec
A custom blockchain platform for the cybersecurity industry called Decentralized Security (DeSec) which has the potential to be a game-changer, similar to how Bitcoin revolutionized finance and Ethereum transformed smart contracts.
# Why DeSec is an exciting concept
Challenges in Cybersecurity:
- Centralized Points of Failure: Many cybersecurity solutions rely on centralized servers, making them vulnerable to hacking attempts.
- Lack of Transparency: Traditional security measures often lack transparency, making it difficult to track threats and verify the effectiveness of defenses.
- Data Silos: Information about security vulnerabilities is often fragmented across different organizations, hindering collaboration and hindering a holistic view of the threat landscape.
- Limited Scalability: Centralized systems can struggle to keep pace with the ever-growing volume of data and cyber threats.
# How DeSec Could Address These Issues
- Enhanced Transparency and Trust: Blockchain technology is known for its transparency and immutability. DeSec could create a shared ledger where security threats, vulnerabilities, and patches are documented and accessible to all participants. This fosters trust and collaboration within the cybersecurity community.
- Improved Threat Intelligence Sharing: DeSec could facilitate the secure and efficient sharing of threat intelligence data between organizations. Real-time threat information could be shared without compromising sensitive details, allowing for faster and more coordinated responses to cyberattacks.
- Decentralized Security Solutions: DeSec could enable the development of decentralized security applications. Imagine a marketplace where security tools and services are offered by various providers, with users subscribing based on their needs. This could lead to more innovative and accessible security solutions.
- Incentivized Security Ecosystem: DeSec could utilize blockchain tokens to incentivize good behavior. Security researchers could be rewarded for identifying vulnerabilities, and users could earn tokens for participating in the network and contributing to its security.
- Increased Scalability: The decentralized nature of blockchain could allow DeSec to scale efficiently to meet the needs of a growing industry.
# Potential Applications of DeSec
- Secure Identity Management: DeSec could be used to create a secure and tamper-proof system for managing digital identities.
- Decentralized Threat Detection: A DeSec network could be used to share and analyze threat data in real-time, allowing for faster detection and response to cyber threats.
- Secure Communication Channels: DeSec could be used to create secure and encrypted communication channels for organizations to share sensitive information.
- Incentivized Bug Bounties: A platform for rewarding security researchers who discover vulnerabilities in software or systems.
# Similar to Bitcoin and Ethereum
- Just like Bitcoin established a decentralized digital currency, DeSec could establish a decentralized security infrastructure.
- Similar to how Ethereum allows for the creation of smart contracts, DeSec could enable the development of secure and automated security applications.
# Contributing
We welcome contributions to the Hyperledger Fabric project in many forms. There’s always plenty to do!

First things first, please review the DeSec Code of Conduct before participating. It is important that we keep things civil.

# Note

If you want to contribute to this documentation, please check out the Style guide for contributors.

# Ways to contribute
There are many ways you can contribute to DeSec, both as a user and as a developer.

# As a user:

- Making Feature/Enhancement Proposals

- Reporting bugs

# As a writer or information developer:

- Update the documentation using your experience of DeSec and this documentation to improve existing topics and create new ones. A documentation change is an easy way to get started as a contributor, makes it easier for other users to understand and use DeSec, and grows your open source commit history.

- Participate in a language translation to keep the DeSec documentation current in your chosen language. The DeSec documentation is available in a number of languages – English, Chinese, Malayalam and Brazilian Portuguese – so why not join a team that keeps your favorite documentation up-to-date? You’ll find a friendly community of users, writers and developers to collaborate with.

- Start a new language translation if the DeSec documentation isn’t available in your language. The Chinese, Malayalam and Portuguese Brazilian teams got started this way, and you can too! It’s more work, as you’ll have to form a community of writers, and organize contributions; but it’s really fulfilling to see the DeSec documentation available in your chosen language.

- Jump to Contributing documentation to get started on your journey.

# As a developer:

- If you only have a little time, consider picking up a “good first issue” task, see Fixing issues and working stories.

- If you can commit to full-time development, either propose a new feature (see Making Feature/Enhancement Proposals) and bring a team to implement it, or join one of the teams working on an existing Epic. If you see an Epic that interests you on the GitHub epic backlog, contact the Epic assignee via the GitHub issue.

# Contributing documentation
It’s a good idea to make your first change a documentation change. It’s quick and easy to do, ensures that you have a correctly configured machine, (including the required pre-requisite software), and gets you familiar with the contribution process. Use the following topics to help you get started:

- Connect with other writers
- Contributing documentation
- Creating a new translation
- Style guide for contributors

# Project Governance
DeSec is managed under an open governance model as described in our charter. Projects and sub-projects are lead by a set of maintainers. New sub-projects can designate an initial set of maintainers that will be approved by the top-level project’s existing maintainers when the project is first approved.

# Maintainers
The DeSec project is lead by the project’s top level maintainers. The maintainers are responsible for reviewing and merging all patches submitted for review, and they guide the overall technical direction of the project within the guidelines established by the DeSec Technical Oversight Committee (TOC).

# Becoming a maintainer
The project’s maintainers will, from time-to-time, consider adding a maintainer, based on the following criteria:

- Demonstrated track record of PR reviews (both quality and quantity of reviews)

- Demonstrated thought leadership in the project

- Demonstrated shepherding of project work and contributors

- An existing maintainer can submit a pull request to the maintainers file. A nominated Contributor may become a Maintainer by a majority approval of the proposal by the existing Maintainers. Once approved, the change set is then merged and the individual is added to the maintainers group.

Maintainers may be removed by explicit resignation, for prolonged inactivity (e.g. 3 or more months with no review comments), or for some infraction of the code of conduct or by consistently demonstrating poor judgement. A proposed removal also requires a majority approval. A maintainer removed for inactivity should be restored following a sustained resumption of contributions and reviews (a month or more) demonstrating a renewed commitment to the project.

# Releases
DeSec provides periodic releases with new features and improvements. New feature work is merged to the DeSec main branch on GitHub. Releases branches are created prior to each release so that the code can stabilize while new features continue to get merged to the main branch. Important fixes will also be backported to the most recent LTS (long-term support) release branch, and to the prior LTS release branch during periods of LTS release overlap.

See releases for more details.

# Making Feature/Enhancement Proposals
- Minor improvements can be implemented and reviewed via the normal GitHub pull request workflow but for changes that are more substantial DeSec follows the RFC (request for comments) process.

- This process is intended to provide a consistent and controlled path for major changes to DeSec and other official project components, so that all stakeholders can be confident about the direction in which DeSec is evolving.

- To propose a new feature, first, check the GitHub issues backlog and the DeSec RFC repository to be sure that there isn’t already an open (or recently closed) proposal for the same functionality. If there isn’t, follow the RFC process to make a proposal.

# Contributor meeting
The maintainers hold regular contributors meetings. The purpose of the contributors meeting is to plan for and review the progress of releases and contributions, and to discuss the technical and operational direction of the project and sub-projects.

Please see the wiki for maintainer meeting details.

New feature/enhancement proposals as described above should be presented to a maintainers meeting for consideration, feedback and acceptance.

# Release roadmap
The DeSec release roadmap is managed as a list of GitHub issues with Epic label.

# Communications and Getting Help
We use the DeSec mailing list for formal communication and Discord for community chat. Feel free to reach out for help on one of the DeSec channels! If you’d like contribution help or suggestions reach out on the #fabric-code-contributors channel.

Our development planning and prioritization is done using a GitHub Issues ZenHub board, and we take longer running discussions/decisions to the DeSec contributor meeting.

The mailing list, Discord, and GitHub each require their own login which you can request upon your first interaction.


# Reporting bugs
If you are a user and you have found a bug, please submit an issue using GitHub Issues. Before you create a new GitHub issue, please try to search the existing issues to be sure no one else has previously reported it. If it has been previously reported, then you might add a comment that you also are interested in seeing the defect fixed.

# Note

- If the defect is security-related, please follow the DeSec security bug reporting process.

- If it has not been previously reported, you may either submit a PR with a well documented commit message describing the defect and the fix, or you may create a new GitHub issue. Please try to provide sufficient information for someone else to reproduce the issue. One of the project’s maintainers should respond to your issue within 24 hours. If not, please bump the issue with a comment and request that it be reviewed. You can also post to the relevant DeSec channel in DeSec Discord. For example, a doc bug should be broadcast to #DeSec-documentation, a peer bug to #DeSec-peer, and so on…

# Submitting your fix
If you just submitted a GitHub issue for a bug you’ve discovered, and would like to provide a fix, we would welcome that gladly! Please assign the GitHub issue to yourself, then submit a pull request (PR). Please refer to GitHub Contributions for a detailed workflow.

# Fixing issues and working stories
- Fabric issues and bugs are managed in GitHub issues. Review the list of issues and find something that interests you. You could also check the “good first issue” list. It is wise to start with something relatively straight forward and achievable, and that no one is already assigned. Please note, due to GitHub permissions, you might not be able to assign issues to yourself. If you find an issue that interests you and is unassigned, please let us know in the chat, and a maintainer will assign it to you. Please be considerate and rescind the assignment if you cannot finish in a reasonable time, or add a comment saying that you are still actively working the issue if you need a little more time.

- While GitHub issues tracks a backlog of known issues that could be worked in the future, if you intend to immediately work on a change that does not yet have a corresponding issue, you can submit a pull request to Github without linking to an existing issue.

# Reviewing submitted Pull Requests (PRs)
- Another way to contribute and learn about DeSec is to help the maintainers with the review of the PRs that are open. Indeed maintainers have the difficult role of having to review all the PRs that are being submitted and evaluate whether they should be merged or not. You can review the code and/or documentation changes, test the changes, and tell the submitters and maintainers what you think. Once your review and/or test is complete just reply to the PR with your findings, by adding comments and/or voting. A comment saying something like “I tried it on system X and it works” or possibly “I got an error on system X: xxx “ will help the maintainers in their evaluation. As a result, maintainers will be able to process PRs faster and everybody will gain from it.

- Just browse through the open PRs on GitHub to get started.

# PR Aging
As the Fabric project has grown, so too has the backlog of open PRs. One problem that nearly all projects face is effectively managing that backlog and Fabric is no exception. In an effort to keep the backlog of DeSec and related project PRs manageable, we are introducing an aging policy which will be enforced by bots. This is consistent with how other large projects manage their PR backlog.

# PR Aging Policy
- The DeSec project maintainers will automatically monitor all PR activity for delinquency. If a PR has not been updated in 2 weeks, a reminder comment will be added requesting that the PR either be updated to address any outstanding comments or abandoned if it is to be withdrawn. If a delinquent PR goes another 2 weeks without an update, it will be automatically abandoned. If a PR has aged more than 2 months since it was originally submitted, even if it has activity, it will be flagged for maintainer review.

- If a submitted PR has passed all validation but has not been reviewed in 72 hours (3 days), it will be flagged to the #DeSec-pr-review channel daily until it receives a review comment(s).

- This policy applies to all official DeSec projects (DeSec, DeSec-ca, DeSec-samples, DeSec-test, DeSec-sdk-node, DeSec-sdk-java, DeSec-sdk-go, DeSec-gateway-java, DeSec-gateway, DeSec-chaincode-go, DeSec-chaincode-node, DeSec-chaincode-java, and DeSec-amcl).

# Setting up development environment
Next, try building the project in your local development environment to ensure that everything is set up correctly.

# What makes a good pull request?
- One change at a time. Not five, not three, not ten. One and only one. Why? Because it limits the blast area of the change. If we have a regression, it is much easier to identify the culprit commit than if we have some composite change that impacts more of the code.

- If there is a corresponding GitHub issue, include a link to the GitHub issue in the PR summary and commit message. Why? Because there will often be additional discussion around a proposed change or bug in the GitHub issue. Additionally, if you use syntax like “Resolves #<GitHub issue number>” in the PR summary and commit message, the GitHub issue will automatically be closed when the PR is merged.

- Include unit and integration tests (or changes to existing tests) with every change. This does not mean just happy path testing, either. It also means negative testing of any defensive code that it correctly catches input errors. When you write code, you are responsible to test it and provide the tests that demonstrate that your change does what it claims. Why? Because without this we have no clue whether our current code base actually works.

- Unit tests should have NO external dependencies. You should be able to run unit tests in place with go test or equivalent for the language. Any test that requires some external dependency (e.g. needs to be scripted to run another component) needs appropriate mocking. Anything else is not unit testing, it is integration testing by definition. Why? Because many open source developers do Test Driven Development. They place a watch on the directory that invokes the tests automagically as the code is changed. This is far more efficient than having to run a whole build between code changes. See this definition of unit testing for a good set of criteria to keep in mind for writing effective unit tests.

- Minimize the lines of code per PR. Why? Maintainers have day jobs, too. If you send a 1,000 or 2,000 LOC change, how long do you think it takes to review all of that code? Keep your changes to < 200-300 LOC, if possible. If you have a larger change, decompose it into multiple independent changes. If you are adding a bunch of new functions to fulfill the requirements of a new capability, add them separately with their tests, and then write the code that uses them to deliver the capability. Of course, there are always exceptions. If you add a small change and then add 300 LOC of tests, you will be forgiven;-) If you need to make a change that has broad impact or a bunch of generated code (protobufs, etc.). Again, there can be exceptions.

# Note

- Large pull requests, e.g. those with more than 300 LOC are more than likely not going to receive an approval, and you’ll be asked to refactor the change to conform with this guidance.

- Write a meaningful commit message. Include a meaningful 55 (or less) character title, followed by a blank line, followed by a more comprehensive description of the change.

# Note

Example commit message:

[FAB-1234] fix foobar() panic

Fix [FAB-1234] added a check to ensure that when foobar(foo string)
is called, that there is a non-empty string argument.
Finally, be responsive. Don’t let a pull request fester with review comments such that it gets to a point that it requires a rebase. It only further delays getting it merged and adds more work for you - to remediate the merge conflicts.
